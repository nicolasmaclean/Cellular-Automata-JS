[{"C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\index.js":"1","C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\react components\\CAGrid.js":"2","C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\CARender.js":"3","C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\import.js":"4","C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\NSet.js":"5","C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\Grid.js":"6","C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\CellularAutomata.js":"7","C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\Vector.js":"8","C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\UserInput.js":"9","C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\Viewer.js":"10"},{"size":389,"mtime":1610582684797,"results":"11","hashOfConfig":"12"},{"size":1461,"mtime":1610582576642,"results":"13","hashOfConfig":"12"},{"size":18236,"mtime":1610582422870,"results":"14","hashOfConfig":"12"},{"size":361,"mtime":1610500886317,"results":"15","hashOfConfig":"12"},{"size":4096,"mtime":1610305865064,"results":"16","hashOfConfig":"12"},{"size":4264,"mtime":1610500444298,"results":"17","hashOfConfig":"12"},{"size":2524,"mtime":1610575762440,"results":"18","hashOfConfig":"12"},{"size":4057,"mtime":1610486771580,"results":"19","hashOfConfig":"12"},{"size":11522,"mtime":1610577717778,"results":"20","hashOfConfig":"12"},{"size":3671,"mtime":1610489776943,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"18koho4",{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"29"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},"C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\index.js",[],"C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\react components\\CAGrid.js",[],"C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\CARender.js",["45","46","47","48","49"],"// this renders a given GridPrender to a HTML canvas\\\r\n\r\nimport {\r\n    CellularAutomata,\r\n    Viewer,\r\n    Vector,\r\n    NSet,\r\n} from './import';\r\n\r\nclass CARender\r\n{\r\n    constructor(configs)\r\n    // constructor(init_loopState, init_windowSize, init_clr_bg = \"#c0c0c0\", cellColors = WWColors, rules = WWRules, init_fps = 10, init_fpsS = 20)\r\n    {\r\n        CARender.fillModesInObj(configs);\r\n\r\n        // configurations\r\n        this.clr_bg = configs.clr_bg;\r\n        this.updateState = configs.loopState;\r\n        this.cellColorsLength = Object.keys(configs.cellColors).length;\r\n        \r\n        // initializes simulation\r\n        this.CellularAutomata = new CellularAutomata(Object.keys(configs.cellColors).length, configs.cellColors, configs.rules);\r\n        this.viewer = new Viewer(configs.windowSize);\r\n        \r\n        // this.CellularAutomata.grid.setCells_val([new Vector(-1, 0), new Vector(0, 0), new Vector(1, 0)], 1);\r\n        this.CellularAutomata.grid.setCells_val([new Vector(-1, 0), new Vector(0, 0), new Vector(1, 0), new Vector(2, 0)], 3);\r\n        this.CellularAutomata.grid.setCells_val([new Vector(-2, 0)], 1)\r\n        \r\n        // FPS controller stuff\r\n        this.fps = configs.fps;\r\n        this.fpsS = configs.fpsStep;\r\n\r\n        this.fpsInterval = 1000 / this.fps;\r\n        this.fpsIntervalS = 1000 / this.fpsS;\r\n\r\n        this.lastFrame = 0;\r\n        this.lastFrameS = 0;\r\n\r\n        // state management\r\n        this.step = false;\r\n        this.paused = configs.paused;\r\n        this.needDraw = true;\r\n\r\n        // input\r\n        this.coordsSet = []; // list of lists that store a coord and value to set at that coord\r\n        this.lineCoordsDone = new NSet(); // stores a set of coords\r\n        this.lineCoordsAdd = new NSet();\r\n\r\n        this.drawSpecificState = false;\r\n        this.drawState = 1;\r\n    }\r\n\r\n    // sets the drawState and clamps values too big\r\n    setDrawState(val)\r\n    {\r\n        this.drawState = val;\r\n\r\n        if(this.drawState >= this.cellColorsLength)\r\n        {\r\n            this.drawState = this.cellColorsLength-1;\r\n        }\r\n    }\r\n\r\n    // TODO: add parameter to control if the fps stuff should be reset provided elapsed is big enough\r\n    // returns the update state and advances the update state\r\n    checkState(updateFPSTracking)\r\n    {\r\n        // frame rate control\r\n        var currentFrame = Date.now();\r\n        var elapsed = currentFrame - this.lastFrame;\r\n        \r\n        var currentFrameS = Date.now();\r\n        var elapsedS = currentFrameS - this.lastFrameS;\r\n        \r\n        // simulation loop\r\n        if (!this.paused && this.updateState === CARender.loopEnum.stepLoop && elapsed > this.fpsInterval)\r\n        {\r\n            if (updateFPSTracking)\r\n            {\r\n                this.lastFrame = currentFrame - (elapsed % this.fpsInterval);\r\n            }\r\n            \r\n            return CARender.renderState.step;\r\n        }\r\n        \r\n        // single step\r\n        else if ((this.updateState !== CARender.loopEnum.stepLoop || this.paused) && this.step && elapsedS > this.fpsIntervalS) // add a fps controller\r\n        {\r\n            if (updateFPSTracking)\r\n            {\r\n                this.lastFrameS = currentFrameS - (elapsedS % this.fpsIntervalS);\r\n            }\r\n            \r\n            this.step = false;\r\n\r\n            return CARender.renderState.step;\r\n        }\r\n        \r\n        // TODO: move viewer.pos == viewer.target pos to be handelled in viewer.update and have it modify viewer.needDraw\r\n        // draw loop\r\n        else if (((this.paused || this.updateState === CARender.loopEnum.drawLoop) && this.needDraw) || this.needDraw || !this.viewer.targetPos.equals(this.viewer.pos))\r\n        {\r\n            this.needDraw = false;\r\n            return CARender.renderState.draw;\r\n        }\r\n\r\n        // no loop\r\n        else if (this.updateState === CARender.loopEnum.noLoop)\r\n        {\r\n            return CARender.renderState.noLoop;\r\n        }\r\n\r\n        // nothing\r\n        else\r\n        {\r\n            return CARender.renderState.nothing;\r\n        }\r\n    }\r\n\r\n    // checks the state of the simulation/render and will step the simulation or render it if necessary. returns true if the update loop should continue.\r\n    Update(drawContext, configs)\r\n    // Update(drawContext, DrawCellFunc = CARender.DrawCell, DrawStyleFunc = CARender.DrawStyle, PreStepFunc = CARender.PreStepDraw, PostStepFunc = CARender.PostStepDraw)\r\n    {\r\n        // stores references to configs functions\r\n        var DrawCellFunc = configs.DrawCellFunc;\r\n        var DrawStyleFunc = configs.DrawStyleFunc;\r\n        var PreStepFunc = configs.PreStepFunc;\r\n        var PostStepFunc = configs.PostStepFunc;\r\n\r\n        // be careful this will update frame controller\r\n        var renderState = this.checkState(true);\r\n\r\n        // steps the simulation\r\n        if (renderState === CARender.renderState.step)\r\n        {\r\n            this.handleInput();\r\n            this.PreStep(drawContext, PreStepFunc);\r\n            this.Step()\r\n            this.PostStep(drawContext, PostStepFunc, DrawStyleFunc, DrawCellFunc);\r\n        }\r\n\r\n        // draws the grid\r\n        else if (renderState === CARender.renderState.draw)\r\n        {\r\n            this.handleInput();\r\n            this.Draw(drawContext, PreStepFunc, PostStepFunc, DrawStyleFunc, DrawCellFunc);\r\n        }\r\n\r\n        // does nothing\r\n        else if (renderState === CARender.renderState.nothing)\r\n        {\r\n            // console.log(\"nothin\");\r\n        }\r\n\r\n        // no loop\r\n        else if (renderState === CARender.renderState.noLoop)\r\n        {\r\n            console.log(\"no loop\");\r\n            return false;\r\n        }\r\n\r\n        // flag to indicate loop should be continued\r\n        return true;\r\n    }\r\n\r\n    // returns a js object with cell colors as keys and stored as their values\r\n    drawGridData()\r\n    {\r\n        var cells = this.CellularAutomata.grid.createBatchObject();\r\n        \r\n        // grid coords within the window bounds, inclusive\r\n        this.xBounds = new Vector(Math.floor(-this.viewer.pos.x/this.viewer.cellSize), Math.floor((-this.viewer.pos.x+this.viewer.windowSize.x)/this.viewer.cellSize));\r\n        this.yBounds = new Vector(Math.floor(-this.viewer.pos.y/this.viewer.cellSize), Math.floor((-this.viewer.pos.y+this.viewer.windowSize.y)/this.viewer.cellSize));\r\n        \r\n        for (var x = this.xBounds.x; x <= this.xBounds.y; x++)\r\n        {\r\n            for (var y = this.yBounds.x; y <= this.yBounds.y; y++)\r\n            {\r\n                // cell info\r\n                var cx = x*this.viewer.cellSize + this.viewer.pos.x;\r\n                var cy = y*this.viewer.cellSize + this.viewer.pos.y;\r\n                var val = this.CellularAutomata.getCell(new Vector(x, y));\r\n                var clr = this.CellularAutomata.grid.cellColors[val];\r\n                \r\n                cells[clr].push(new Vector(cx, cy));\r\n            }\r\n        }\r\n\r\n        return cells;\r\n    }\r\n\r\n    // TODO: update the way it cycles through cell states\r\n    // handles input stored in the Viewer object\r\n    handleInput()\r\n    {\r\n        // toggles coords in the line that haven't already been processed\r\n        NSet.difference(this.lineCoordsAdd, this.lineCoordsDone).forEach( val => \r\n        {\r\n            if (this.drawSpecificState)\r\n            {\r\n                this.CellularAutomata.setCell(val, this.drawState);\r\n            }\r\n            else\r\n            {\r\n                this.CellularAutomata.cycleCell(val);\r\n            }\r\n        })\r\n\r\n        // updates the sets\r\n        this.lineCoordsDone.union(this.lineCoordsAdd);\r\n        this.lineCoordsAdd = new NSet();\r\n\r\n        // sets given coords with their requested value\r\n        for (let x in this.coordsSet)\r\n        {\r\n            this.CellularAutomata.setCell(x[0], x[1]);\r\n        }\r\n    }\r\n\r\n    // simulation\r\n    Step()\r\n    {\r\n        this.handleInput();\r\n        this.CellularAutomata.step();\r\n    }\r\n    \r\n    // perfroms draw without stepping the simulation\r\n    Draw(draw, PreStepFunc, PostStepFunc, DrawStyleFunc, DrawCellFunc)\r\n    {\r\n        this.PreStep(draw, PreStepFunc);\r\n        this.PostStep(draw, PostStepFunc, DrawStyleFunc, DrawCellFunc);\r\n    }\r\n\r\n    // pre simulation\r\n    PreStep(drawContext, PreStepFunc)\r\n    {\r\n        // clears the canvas\r\n        var clr = this.clr_bg;\r\n        var windowSize = this.viewer.windowSize;\r\n        PreStepFunc(drawContext, clr, windowSize);\r\n        \r\n        this.viewer.Update();\r\n    }\r\n\r\n    // post simulation\r\n    PostStep(drawContext, PostStepFunc, DrawStyleFunc, DrawCellFunc)\r\n    {\r\n        var gridData = this.drawGridData();\r\n        var cellSize = this.viewer.cellSize;\r\n        CARender.DrawGrid(gridData, cellSize, drawContext, DrawStyleFunc, DrawCellFunc);\r\n        \r\n        // TODO: separate this into a second \"UI\" canvas that is painted ontop of the grid canvas\r\n        var bg = this.clr_bg;\r\n        var windowSize = this.viewer.windowSize;\r\n        PostStepFunc(drawContext, bg, windowSize);\r\n    }\r\n\r\n    // draws the grid retrieved from this\r\n    static DrawGrid(gridData, cellSize, drawContext, DrawStyleFunc, DrawCellFunc)\r\n    {\r\n        // cycles through colors\r\n        for (let clr in gridData)\r\n        {\r\n            // sets fill color/style to take advantage of color batching\r\n            DrawStyleFunc(drawContext, clr);\r\n            \r\n            // cycles through coordinates\r\n            for (let coordIndex in gridData[clr])\r\n            {\r\n                var coord = gridData[clr][coordIndex];\r\n\r\n                // draws current cell\r\n                DrawCellFunc(drawContext, coord, cellSize);\r\n            }\r\n        }\r\n    }\r\n\r\n    // The following 4 functions serve as default rendering options for HTML canvas utilizing the 2d context\r\n    // draws a cell of given size at given screen coordinate, note cell color is not set in this method\r\n    static DrawCell(drawContext, coord, cellSize)\r\n    {\r\n        drawContext.fillRect(coord.x, coord.y, cellSize-1, cellSize-1);\r\n    }\r\n\r\n    // clears the canvas\r\n    static PreStepDraw(drawContext, clr, windowSize)\r\n    {\r\n        drawContext.fillStyle = clr;\r\n        drawContext.fillRect(0, 0, windowSize.x, windowSize.y);\r\n    }\r\n\r\n    // draws a border around the grid\r\n    static PostStepDraw(drawContext, clr, windowSize)\r\n    {\r\n        drawContext.strokeStyle = clr;\r\n        drawContext.moveTo(1, 1);\r\n        drawContext.lineTo(1, windowSize.y-1);\r\n        drawContext.lineTo(windowSize.x-1, windowSize.y-1);\r\n        drawContext.lineTo(windowSize.x-1, 1);\r\n        drawContext.lineTo(1, 1);\r\n        drawContext.stroke();\r\n    }\r\n\r\n    // sets the fill style prior to drawing a batch of cells\r\n    static DrawStyle(drawContext, clr)\r\n    {\r\n        drawContext.fillStyle = clr;\r\n    }\r\n\r\n    // fills in missing properties with default values\r\n    static fillJSObjectBlanks(obj)\r\n    {\r\n        var defaultObj = CARender.JSObjectDefault();\r\n        \r\n        if (obj.width === undefined) { obj.width = defaultObj.width}\r\n        if (obj.height === undefined) { obj.height = defaultObj.height}\r\n        if (obj.windowSize === undefined) { obj.windowSize = new Vector(obj.width, obj.height)}\r\n        \r\n        if (obj.x === undefined) { obj.x = defaultObj.x}\r\n        if (obj.y === undefined) { obj.y = defaultObj.y}\r\n        if (obj.position === undefined) { obj.position = new Vector(obj.x, obj.y)}\r\n\r\n        if (obj.cellColors === undefined) { obj.cellColors = defaultObj.cellColors}\r\n        if (obj.rules === undefined) { obj.rules = defaultObj.rules}\r\n        \r\n        if (obj.loop === undefined) { obj.loop = defaultObj.loop}\r\n        if (obj.clr_bg === undefined) { obj.clr_bg = defaultObj.clr_bg}\r\n        if (obj.fps === undefined) { obj.fps = defaultObj.fps}\r\n        if (obj.fpsStep === undefined) { obj.fpsStep = defaultObj.fpsStep}\r\n        if (obj.zoom === undefined) { obj.zoom = defaultObj.zoom}\r\n        if (obj.maxZoom === undefined) { obj.maxZoom = defaultObj.maxZoom}\r\n        if (obj.minZoom === undefined) { obj.minZoom = defaultObj.minZoom}\r\n        if (obj.paused === undefined) { obj.paused = defaultObj.paused}\r\n\r\n        if (obj.DrawCellFunc === undefined) { obj.DrawCellFunc = defaultObj.DrawCellFunc}\r\n        if (obj.DrawStyleFunc === undefined) { obj.DrawStyleFunc = defaultObj.DrawStyleFunc}\r\n        if (obj.PreStepFunc === undefined) { obj.PreStepFunc = defaultObj.PreStepFunc}\r\n        if (obj.PostStepFunc === undefined) { obj.PostStepFunc = defaultObj.PostStepFunc}\r\n    }\r\n\r\n    // returns the default configuration\r\n    static JSObjectDefault()\r\n    {\r\n        var obj = {\r\n            loopState: 2,\r\n            width: 500,\r\n            height: 600,\r\n            windowSize: new Vector(500, 600),\r\n            clr_bg: \"#c0c0c0\",\r\n            cellColors: \"wire world\", // allow a custom javascript obj of colors, \"game of life\" or \"wire world\" or some other predefined one, or use wireworld as default\r\n            rules: \"wire world\", // allow a custom array of rule functions, \"game of life\" or \"wire world\" or some other predefined one, or use wireworld as default\r\n            fps: 10,\r\n            fpsStep: 20,\r\n            x: 0,\r\n            y: 0,\r\n            position: new Vector(0, 0),\r\n            zoom: 1,\r\n            maxZoom: 9,\r\n            minZoom: .8,\r\n            paused: false,\r\n        \r\n            DrawCellFunc: CARender.DrawCell,\r\n            DrawStyleFunc: CARender.DrawStyle,\r\n            PreStepFunc: CARender.PreStepDraw,\r\n            PostStepFunc: CARender.PostStepDraw,\r\n        };\r\n\r\n        return obj;\r\n    }\r\n\r\n    // fills in string modes for cell colors and rules. For example, it would convert cellColor: \"wire world\" into {0: 'white', 1: 'yellow', 2: 'red', 3: 'black'}\r\n    static fillModesInObj(configs)\r\n    {\r\n        // exits if both colors and rules are objects/functions\r\n        if (typeof configs.cellColors !== \"string\" && typeof configs.rules !== \"string\") return;\r\n        \r\n        // removes case sensitivity\r\n        if (typeof configs.cellColors === \"string\")\r\n        {\r\n            configs.cellColors.toLowerCase();\r\n        }\r\n\r\n        if (typeof configs.rules === \"string\")\r\n        {\r\n            configs.rules.toLowerCase();\r\n        }\r\n\r\n        // checks for cell colors\r\n        if (configs.cellColors === \"wire world\")\r\n        {\r\n            configs.cellColors = {0: 'white', 1: 'yellow', 2: 'red', 3: 'black'};\r\n        }\r\n        else if (configs.cellColors === \"game of life\")\r\n        {\r\n            configs.cellColors = {0: 'white', 1: 'black'};\r\n        }\r\n\r\n        if (configs.rules === \"wire world\")\r\n        {\r\n            configs.rules = [\r\n                (neighborsValues, curVal) => {return [curVal === 0, 0];},\r\n                (neighborsValues, curVal) => {return [curVal === 1, 2];},\r\n                (neighborsValues, curVal) => {return [curVal === 2, 3];},\r\n                (neighborsValues, curVal) => {\r\n                    // gets live neighbor count\r\n                    var liveNeighbors = neighborsValues.filter( (val) => { return val === 1; } );\r\n                    liveNeighbors = liveNeighbors.length;\r\n                    \r\n                    // gets the outcome of the rule\r\n                    var result = (curVal === 3 && (liveNeighbors === 2 || (liveNeighbors === 1)));\r\n                    \r\n                    // formats the output\r\n                    return [curVal === 3, result ? 1 :  3];},\r\n            ];\r\n        }\r\n        else if (configs.rules === \"game of life\")\r\n        {\r\n            configs.rules = [ (neighborsValues, curVal) => {\r\n                // gets live neighbor count\r\n                var liveNeighbors = neighborsValues.filter( (val) => { return val === 1; } );\r\n                liveNeighbors = liveNeighbors.length;\r\n\r\n                // gets the outcome of the rule\r\n                var result = (curVal === 1 && (liveNeighbors === 2)) || (liveNeighbors === 3);\r\n\r\n                // formats the output\r\n                return [result, result ? 1 :  0];\r\n            }]\r\n        }\r\n    }\r\n}\r\n\r\n// GAME OF LIFE\r\n// example rule function to be passes through. The output should be an array of length 2. The first element is a boolean that specifies if this \r\n// result is the final result. The second element is the new cell state.\r\nfunction GameOfLifeRule(neighborsValues, curVal)\r\n{\r\n    // gets live neighbor count\r\n    var liveNeighbors = neighborsValues.filter( (val) => { return val === 1; } );\r\n    liveNeighbors = liveNeighbors.length;\r\n\r\n    // gets the outcome of the rule\r\n    var result = (curVal === 1 && (liveNeighbors === 2)) || (liveNeighbors === 3);\r\n\r\n    // formats the output\r\n    return [result, result ? 1 :  0];\r\n}\r\n\r\n// WIRE WORLD\r\n// second example that shows how to implement wireworld. There are 4 cell states and I use 4 rules as shown below to implement it.\r\n\r\n// background remains background\r\nfunction wireWorld1(neighborsValues, curVal)\r\n{\r\n    return [curVal === 0, 0];\r\n}\r\n\r\n// electron head becomes electron tail\r\nfunction wireWorld2(neighborsValues, curVal)\r\n{\r\n    return [curVal === 1, 2];\r\n}\r\n\r\n// electron tail becomes wire\r\nfunction wireWorld3(neighborsValues, curVal)\r\n{\r\n    return [curVal === 2, 3];\r\n}\r\n\r\n// wire becomes electron head if there electron(s) adjacent\r\nfunction wireWorld4(neighborsValues, curVal)\r\n{\r\n    // gets live neighbor count\r\n    var liveNeighbors = neighborsValues.filter( (val) => { return val === 1; } );\r\n    liveNeighbors = liveNeighbors.length;\r\n    \r\n    // gets the outcome of the rule\r\n    var result = (curVal === 3 && (liveNeighbors === 2 || (liveNeighbors === 1)));\r\n    \r\n    // formats the output\r\n    return [curVal === 3, result ? 1 :  3];\r\n}\r\n\r\n// Game of Life and Wire World rules/colors set as static variables for easy default modes\r\n// live and dead\r\n// var GOLColors = { 0: 'white', 1: 'black' };\r\n// var GOLRules = [GameOfLifeRule];\r\n\r\n// // background, electron head, electron tail, wire\r\n// var WWRules = [wireWorld1, wireWorld2, wireWorld3, wireWorld4];\r\n\r\n// enums\r\nCARender.renderState = {\r\n    step: 0,\r\n    draw: 1,\r\n    nothing: 2,\r\n    noLoop: 3\r\n}\r\n\r\nCARender.loopEnum = {\r\n    noLoop: 0,\r\n    drawLoop: 1,\r\n    stepLoop: 2,\r\n    step: 3\r\n}\r\n\r\nexport default CARender;",["50","51"],"C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\import.js",[],"C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\NSet.js",[],["52","53"],"C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\Grid.js",[],"C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\CellularAutomata.js",[],"C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\Vector.js",[],"C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\UserInput.js",[],"C:\\Users\\nicol\\Documents\\GitHub\\Cellular-Automata-JS\\examples\\React\\react-ca\\src\\Cellular-Automata-JS\\Viewer.js",[],{"ruleId":"54","severity":1,"message":"55","line":437,"column":10,"nodeType":"56","messageId":"57","endLine":437,"endColumn":24},{"ruleId":"54","severity":1,"message":"58","line":454,"column":10,"nodeType":"56","messageId":"57","endLine":454,"endColumn":20},{"ruleId":"54","severity":1,"message":"59","line":460,"column":10,"nodeType":"56","messageId":"57","endLine":460,"endColumn":20},{"ruleId":"54","severity":1,"message":"60","line":466,"column":10,"nodeType":"56","messageId":"57","endLine":466,"endColumn":20},{"ruleId":"54","severity":1,"message":"61","line":472,"column":10,"nodeType":"56","messageId":"57","endLine":472,"endColumn":20},{"ruleId":"62","replacedBy":"63"},{"ruleId":"64","replacedBy":"65"},{"ruleId":"62","replacedBy":"66"},{"ruleId":"64","replacedBy":"67"},"no-unused-vars","'GameOfLifeRule' is defined but never used.","Identifier","unusedVar","'wireWorld1' is defined but never used.","'wireWorld2' is defined but never used.","'wireWorld3' is defined but never used.","'wireWorld4' is defined but never used.","no-native-reassign",["68"],"no-negated-in-lhs",["69"],["68"],["69"],"no-global-assign","no-unsafe-negation"]